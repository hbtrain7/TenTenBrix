<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>TenTenBrix v1.3 - Ranking System</title>
  <style>
    :root {
      --primary-color: #e94560;
      --text-color: #ffffff;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #1a1a2e;
      font-family: 'Segoe UI', sans-serif;
      color: var(--text-color);
      touch-action: none;
    }

    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
      background-color: #16213e;
      border: 3px solid #30475e;
      cursor: pointer;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 5;
      padding: 20px;
      box-sizing: border-box;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      /* ì•„ì´í…œë“¤ì´ ì„¸ë¡œ ì¤‘ì•™ì— ì˜¤ë„ë¡ */
      font-size: 0.9rem;
      /* ì „ì²´ì ì¸ ê¸€ì í¬ê¸° ì¶•ì†Œ (1.2 -> 0.9) */
      font-weight: bold;
    }

    .hud-item {
      background: rgba(0, 0, 0, 0.8);
      /* ì ¤ë¦¬ì™€ ê²¹ì³ë„ ì˜ ë³´ì´ê²Œ ë°°ê²½ ì§„í•˜ê²Œ */
      padding: 5px 12px;
      /* ìœ„ì•„ë˜ íŒ¨ë”© ì¤„ì„ */
      border-radius: 8px;
      pointer-events: auto;
      border: 1.5px solid var(--primary-color);
      /* í…Œë‘ë¦¬ë„ ì¡°ê¸ˆ ì–‡ê²Œ */
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #pauseBtn {
      min-width: 35px;
      justify-content: center;
      font-size: 1.2rem;
      /* ê¸°í˜¸ëŠ” ì¡°ê¸ˆ ì»¤ì•¼ ì˜ ë³´ì„ */
    }

    .screen {
      position: absolute;
      inset: 0;
      background-image: url('img/main_img.png');
      background-size: cover;
      background-position: center;

      /* ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ë°ì•„ ê¸€ìê°€ ì•ˆ ë³´ì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ì‚´ì§ ì–´ë‘¡ê²Œ ì²˜ë¦¬ */
      background-color: rgba(0, 0, 0, 0.4);
      background-blend-mode: darken;

      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      pointer-events: auto;
    }

    /* ê²Œì„ì˜¤ë²„ ìŠ¤í¬ë¦° ì „ìš©: ë°°ê²½ì„ ë” ì–´ë‘¡ê²Œ í•´ì„œ ë¶„ìœ„ê¸° ì „í™˜ */
    #gameover-screen {
      background-color: rgba(0, 0, 0, 0.85) !important;
      /* !importantë¡œ ìš°ì„ ìˆœìœ„ í™•ë³´ */
      background-blend-mode: multiply;
      /* ì–´ë‘¡ê²Œ í•©ì„± */
    }

    .screen.hidden {
      display: none !important;
      /* í™•ì‹¤í•˜ê²Œ ìˆ¨ê¹€ */
    }

    h1 {
      font-size: 3.5rem;
      color: var(--primary-color);
      text-shadow: 0 0 15px var(--primary-color);
      margin: 0 0 10px 0;
    }

    .btn {
      background: var(--primary-color);
      border: none;
      padding: 18px 50px;
      font-size: 1.8rem;
      color: white;
      border-radius: 60px;
      cursor: pointer;
      transition: 0.2s;
      font-weight: bold;
      box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
    }
  </style>
</head>

<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
      <div class="hud">
        <div class="hud-item">SCORE: <span id="scoreVal">0</span> <span id="combo-text"
            style="color:#00ffcc; margin-left:10px; display:none;"></span></div>
        <div id="bombBtn" class="hud-item"
          style="cursor:pointer; background: rgba(163, 73, 235, 0.2); border: 1px solid #a349eb; color: #dcbfff;">BOMB:
          <span id="bombCount">0</span>
        </div>
        <div id="pauseBtn" class="hud-item" style="cursor:pointer;" onclick="togglePause()">PAUSE</div>
      </div>
    </div>

    <div id="start-screen" class="screen">
      <h1>TenTenBrix</h1>

      <p style="color: #ffce00; font-weight: bold; margin: 0 0 10px 0; font-size: 1rem;">[ ì ¤ë¦¬ì»¨ì…‰ ë””ìì¸ ì ìš©ì¤‘ ]</p>

      <p id="playerDisplay" style="font-size: 1.1rem; color: #ffffff; margin-bottom: 5px; opacity: 0.8;">PLAYER: -</p>

      <p id="mainBestDisplay" style="font-size: 1.2rem; margin-bottom: 30px; color: #00e676;">BEST: 0</p>

      <button id="realStartBtn" class="btn">START GAME</button>
    </div>

    <div id="gameover-screen" class="screen hidden">
      <h1>GAME OVER</h1>

      <div style="text-align: center; margin: 10px 0;">
        <p style="font-size: 1.1rem; color: #aaa; margin: 5px 0;">YOUR SCORE</p>
        <p id="finalScoreDisplay" style="font-size: 2.5rem; margin: 0; color: #ffce00; font-weight: bold;">0</p>
      </div>

      <div id="ranking-board"
        style="background: rgba(255,255,255,0.05); width: 80%; max-width: 300px; padding: 15px; border-radius: 15px; margin-bottom: 20px; border: 1px solid rgba(0,230,118,0.3);">
        <p style="font-size: 1rem; color: #00e676; margin: 0 0 10px 0; font-weight: bold;">ğŸ† REAL-TIME RANKING</p>
        <div id="ranking-list" style="font-size: 0.9rem; text-align: left; line-height: 1.6;">
          <p style="text-align: center; color: #888;">ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
        </div>
      </div>

      <button class="btn" onclick="showStartScreen()" style="padding: 12px 40px; font-size: 1.4rem;">RETRY</button>
    </div>
  </div>

  <script>
    // --- [1] ë³€ìˆ˜ ì„¤ì • ---
    // --- [1] ë³€ìˆ˜ ì„¤ì • ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreVal');
    const comboEl = document.getElementById('combo-text');
    const finalScoreEl = document.getElementById('finalScoreDisplay');

    const COLS = 6, ROWS = 11;
    const DEADLINE = 1;

    const SPAWN_BALANCE_PROB = 0.5;    // ë³´ì • í™•ë¥  (0.5 = 50% í™•ë¥ ë¡œ í•„ìš”í•œ ìˆ«ì ìƒì„±)
    const DANGER_THRESHOLD = 6;        // ë³´ì • ë°œë™ ì¡°ê±´ (í•œ ìˆ«ìê°€ 6ê°œ ì´ìƒ ìŒ“ì˜€ì„ ë•Œ)

    let BLOCK_SIZE, grid = [], score = 0, combo = 0, autoCombo = 0, lastMatchTime = 0;
    let gameActive = false, isPaused = false, fallingBricks = [], lastTime = 0, spawnCounter = 0, selectedBricks = [];
    let effects = [];

    let inventory = { crossBomb: 0 };
    let fieldItems = [];
    let isItemMode = false;
    let lastItemScore = 0;
    let globalBrickCounter = 0; // ë¸Œë¦­ë§ˆë‹¤ ë²ˆí˜¸ë¥¼ í•˜ë‚˜ì”© ë¶™ì—¬ì¤„ ì¹´ìš´í„°
    const ITEM_THRESHOLD = 10000;

    const TERMINAL_VELOCITY = 0.025;
    const STAGES = [
      { score: 5000, interval: 1000, gravity: 0.00001, count: 1 },    // 1ë‹¨ê³„
      { score: 10000, interval: 1000, gravity: 0.00001, count: 2 },   // 2ë‹¨ê³„
      { score: 30000, interval: 900, gravity: 0.00001, count: 2 },   // 3ë‹¨ê³„
      { score: 80000, interval: 900, gravity: 0.00002, count: 2 },    // 4ë‹¨ê³„ (ì¶”ê°€!)
      { score: 150000, interval: 900, gravity: 0.00002, count: 3 }    // 5ë‹¨ê³„ (ì¶”ê°€!)
    ];

    // ì¸íŠ¸ë¡œ ìŒì›ì„ ë”°ë¡œ ë‘ì§€ ì•Šê³  gameOver ìŒì›ì„ ê³µìš©ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    const bgm = new Audio('sfx/bgm.mp3');
    const matchSfx = new Audio('sfx/matchSuccess.mp3');
    const endSfx = new Audio('sfx/endSfx.mp3');
    const gameOverSfx = new Audio('sfx/gameover.mp3'); // ëŒ€ê¸°/ì—”ë”© ê³µìš©
    const selBrickSfx = new Audio('sfx/brickSelect.mp3');
    const matchFailedSfx = new Audio('sfx/matchFailed.mp3');
    const selCrossBombSfx = new Audio('sfx/crossBombSelect.mp3');
    const crossBombSfx = new Audio('sfx/crossBomb.mp3');
    bgm.loop = true;
    gameOverSfx.loop = true; // ëŒ€ê¸° í™”ë©´ì—ì„œë„ ê³„ì† ë‚˜ì™€ì•¼ í•˜ë¯€ë¡œ ë£¨í”„ ì„¤ì •

    let playerName = "";
    let highScore = localStorage.getItem('tenten_highscore') || 0;

    // 1. ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ (í•¨ìˆ˜ ë°– ìƒë‹¨)
    const brickImages = {};


    //ë­í‚¹í‘œì‹œë¥¼ ìœ„í•œ ë³€ìˆ˜
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwQ7liKKIGx_3qWKFYD_j_EDslF1i2DgOhP48P5O0V_8LVW8e0898ZdiFxnob19NaVT/exec";
    // --- [2] ì´ˆê¸°í™” ---
    function init() {
      loadAssets();
      resize();
      const playIntroOnce = () => {
        gameOverSfx.play().catch(e => { });
        window.removeEventListener('mousedown', playIntroOnce);
        window.removeEventListener('touchstart', playIntroOnce);
      };
      window.addEventListener('mousedown', playIntroOnce);
      window.addEventListener('touchstart', playIntroOnce);
      window.addEventListener('resize', resize);

      const bombBtn = document.getElementById('bombBtn');
      if (bombBtn) {
        bombBtn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          if (inventory.crossBomb > 0) {
            isItemMode = !isItemMode;
            if (isItemMode) {
              try { selCrossBombSfx.currentTime = 0; selCrossBombSfx.play().catch(e => { }); } catch (e) { }
            }
            updateItemUI();
          }
        });
      }

      document.getElementById('realStartBtn').onclick = startGame;
      canvas.addEventListener('mousedown', handleInput);
      canvas.addEventListener('touchstart', (e) => {
        if (gameActive) e.preventDefault();
        handleInput(e.touches[0]);
      }, { passive: false });

      grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      showStartScreen();
    }

    function loadAssets() {
      for (let i = 1; i <= 9; i++) {
        const img = new Image();

        // íŒŒì¼ëª…ì´ 01.png, 02.png... í˜•íƒœì¸ ê²½ìš°
        img.src = `img/0${i}.png`;

        // ë¡œë“œ ì„±ê³µ í™•ì¸ìš© ë¡œê·¸ (ê°œë°œ ì¤‘ì—ë§Œ í™•ì¸í•˜ì„¸ìš”)
        img.onload = () => console.log(`Jelly ${i} loaded!`);
        img.onerror = () => console.error(`Failed to load: img/0${i}.png`);

        brickImages[i] = img;
      }
    }

    function resize() {
      // 1. ê°€ë¡œ ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¸Œë¦­ í¬ê¸°ë¥¼ ê³„ì‚° (í™”ë©´ ë„ˆë¹„ 100% í™œìš©)
      const sizeBasedOnWidth = window.innerWidth / COLS;

      // 2. ì„¸ë¡œ ë†’ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¸Œë¦­ í¬ê¸°ë¥¼ ê³„ì‚° (í™”ë©´ ë†’ì´ 100% í™œìš©)
      // ì‚¬ì¥ë‹˜ ì˜ë„ëŒ€ë¡œ ì—¬ë°± ì—†ì´ innerHeight ì „ì²´ë¥¼ ROWSë¡œ ë‚˜ëˆ•ë‹ˆë‹¤.
      const sizeBasedOnHeight = window.innerHeight / ROWS;

      // 3. ë¸Œë¦­ í¬ê¸° ê²°ì • (ë‘˜ ì¤‘ ë” 'í°' ë¸Œë¦­ì„ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì œì•½ì¡°ê±´ì„ ì„ íƒ)
      // ë³´í†µ ìŠ¤ë§ˆíŠ¸í°ì€ ê°€ë¡œê°€ ì¢ìœ¼ë¯€ë¡œ sizeBasedOnWidthê°€ ì„ íƒë˜ì–´ ê°€ë¡œì— ê½‰ ì°¨ê²Œ ë©ë‹ˆë‹¤.
      BLOCK_SIZE = Math.min(sizeBasedOnWidth, sizeBasedOnHeight);

      // 4. ìº”ë²„ìŠ¤ ì‹¤ì œ í¬ê¸° ì„¤ì •
      canvas.width = COLS * BLOCK_SIZE;
      canvas.height = ROWS * BLOCK_SIZE;

      // 5. í™”ë©´ ì¤‘ì•™ ì •ë ¬ ë° ìµœìƒë‹¨ ë°€ì°©
      canvas.style.position = "absolute";
      canvas.style.top = "0px"; // ìƒë‹¨ ì—¬ë°± 0

      // í™”ë©´ ì¤‘ì•™ ë°°ì¹˜ë¥¼ ìœ„í•œ ê³„ì‚°
      const horizontalMargin = (window.innerWidth - canvas.width) / 2;
      canvas.style.left = horizontalMargin + "px";
    }

    function setupPlayerName() {
      // 1. ì €ì¥ëœ ì´ë¦„ì´ ìˆëŠ”ì§€ ë¨¼ì € í™•ì¸
      let savedName = localStorage.getItem('tenten_playername');

      // 2. ì´ë¦„ì´ ì´ë¯¸ ìˆë‹¤ë©´ ë¬»ì§€ ì•Šê³  ë°”ë¡œ ì „ì—­ ë³€ìˆ˜ì— í• ë‹¹ í›„ ì¢…ë£Œ
      if (savedName) {
        playerName = savedName;
        console.log("ê¸°ì¡´ ìœ ì € ì ‘ì†:", playerName);
        return;
      }

      // 3. ì²˜ìŒ ë°©ë¬¸í•œ ê²½ìš°ì—ë§Œ ë”± í•œ ë²ˆ ë¬¼ì–´ë´„
      const input = prompt("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!\n(ì·¨ì†Œí•˜ê±°ë‚˜ ë¯¸ì…ë ¥ ì‹œ ìë™ ìƒì„±ë©ë‹ˆë‹¤)", "");

      if (input && input.trim() !== "") {
        // ìœ ì €ê°€ ì´ë¦„ì„ ì§ì ‘ ì…ë ¥í•œ ê²½ìš°
        savedName = input.trim();
      } else {
        // ì·¨ì†Œë¥¼ ëˆ„ë¥´ê±°ë‚˜ ë¹ˆì¹¸ì¸ ê²½ìš° -> ì¦‰ì‹œ ìë™ ìƒì„±
        const randomId = Math.floor(1000 + Math.random() * 9000);
        savedName = "TEN-" + randomId;
      }

      // 4. ê²°ì •ëœ ì´ë¦„ì„ ë¡œì»¬ì— ì €ì¥í•˜ê³  ë³€ìˆ˜ì— í• ë‹¹
      localStorage.setItem('tenten_playername', savedName);
      playerName = savedName;
      console.log("ìƒˆ ìœ ì € ìƒì„±:", playerName);
    }

    function spawnBricks(count) {
      // 1. í˜„ì¬ í™”ë©´ì˜ ìˆ«ì ë¶„í¬ íŒŒì•… (ê·¸ë¦¬ë“œ + ë‚™í•˜ ì¤‘ì¸ ë¸Œë¦­)
      const counts = {};

      // ê·¸ë¦¬ë“œì— ê³ ì •ëœ ë¸Œë¦­ ìŠ¤ìº”
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = grid[y][x];
          if (cell && cell !== 0 && !cell.isDestroying) {
            counts[cell.value] = (counts[cell.value] || 0) + 1;
          }
        }
      }
      // í˜„ì¬ ë–¨ì–´ì§€ê³  ìˆëŠ” ë¸Œë¦­ ìŠ¤ìº”
      fallingBricks.forEach(b => {
        counts[b.value] = (counts[b.value] || 0) + 1;
      });

      // 2. ìœ„í—˜ ìˆ«ì(DANGER_THRESHOLD ì´ìƒ)ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì§ê¿ ìˆ«ì ê²°ì •
      let targetPartner = null;
      for (let val in counts) {
        if (counts[val] >= DANGER_THRESHOLD) {
          targetPartner = 10 - parseInt(val);
          break; // ê°€ì¥ ë§ì´ ìŒ“ì¸ ê²ƒ í•˜ë‚˜ë§Œ íƒ€ê²ŸíŒ…
        }
      }

      // 3. ë¸Œë¦­ ìƒì„± ë£¨í”„
      for (let i = 0; i < count; i++) {
        const x = Math.floor(Math.random() * COLS);
        if (grid[0][x] !== 0) { gameOver(); return; }

        let val;
        // ì„¤ì •ëœ í™•ë¥ (SPAWN_BALANCE_PROB)ì— ë”°ë¼ ë³´ì •ê°’ ì ìš©
        if (targetPartner && Math.random() < SPAWN_BALANCE_PROB) {
          val = targetPartner;
        } else {
          val = Math.floor(Math.random() * 9) + 1;
        }

        // ê³ ìœ  ID ë¶€ì—¬ (ìˆ«ìê°€ ê°™ì•„ë„ ì„œë¡œ ë‹¤ë¥¸ ë¸Œë¦­ì„ì„ ì¦ëª…)
        const uniqueId = `brick-${Date.now()}-${globalBrickCounter++}`;

        fallingBricks.push({
          id: uniqueId,
          x: x,
          y: -1,
          value: val,
          vy: 0
        });
      }
    }

    function spawnItem() {
      fieldItems.push({ x: -50, y: Math.random() * (canvas.height - 100) + 50, vx: 2, radius: 25, type: 'crossBomb', angle: 0 });
    }

    function handleInput(e) {
      if (!gameActive || isPaused) return;

      // 0. ì¢Œí‘œ ê³„ì‚° ë° í„°ì¹˜ ëŒ€ì‘
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      const sx = clientX - rect.left;
      const sy = clientY - rect.top;

      // 1. [ì•„ì´í…œ ìˆ˜ì§‘] í•„ë“œ ì•„ì´í…œ ìµœìš°ì„  ì²˜ë¦¬
      for (let i = fieldItems.length - 1; i >= 0; i--) {
        const it = fieldItems[i];
        if (Math.hypot(it.x - sx, it.y - sy) < it.radius + 20) {
          inventory.crossBomb++;
          fieldItems.splice(i, 1);
          updateItemUI();
          return;
        }
      }

      const cx = Math.floor(sx / BLOCK_SIZE);
      const cy = Math.floor(sy / BLOCK_SIZE);

      if (cx < 0 || cx >= COLS || cy < 0 || cy >= ROWS) {
        selectedBricks = [];
        return;
      }

      // 2. [ì•„ì´í…œ ì‚¬ìš© ì‹¤í–‰] í¬ë¡œìŠ¤ë°¤ ëª¨ë“œ í™œì„±í™” ì‹œ
      if (isItemMode && inventory.crossBomb > 0) {
        executeCrossBomb(cx, cy);
        isItemMode = false;
        inventory.crossBomb--;
        updateItemUI();
        selectedBricks = [];
        return;
      }

      // 3. [ì¼ë°˜ ë¸Œë¦­ ì„ íƒ ë¡œì§]
      if (grid[cy] && grid[cy][cx] && grid[cy][cx].isDestroying) return;

      let clicked = null;
      // [ë³´ì •] ë‚™í•˜ ë¸Œë¦­ ê²€ìƒ‰
      const fIdx = fallingBricks.findIndex(b => b.x === cx && Math.abs(b.y - cy) < 0.7);

      if (fIdx > -1) {
        clicked = { ...fallingBricks[fIdx], isFalling: true };
      } else if (grid[cy] && grid[cy][cx] && grid[cy][cx] !== 0) {
        clicked = {
          x: cx,
          y: cy,
          value: grid[cy][cx].value,
          isFalling: false,
          id: grid[cy][cx].id
        };
      }

      if (clicked) {
        const idx = selectedBricks.findIndex(s => s.id === clicked.id);
        if (idx > -1) {
          selectedBricks.splice(idx, 1);
        } else {
          selectedBricks.push(clicked);
          try {
            selBrickSfx.currentTime = 0;
            selBrickSfx.play().catch(e => { });
          } catch (e) { }

          if (selectedBricks.length === 2) {
            const s1 = selectedBricks[0];
            const s2 = selectedBricks[1];

            if (s1.value + s2.value === 10) {
              // --- ë§¤ì¹­ ì„±ê³µ ---
              const now = Date.now();
              combo = (now - lastMatchTime < 2000) ? Math.min(combo + 1, 10) : 1;
              lastMatchTime = now;

              const targetIds = selectedBricks.map(s => s.id);
              selectedBricks = [];

              // [1] ì§„ë™ ì‹œì‘ (ë°ì´í„°ëŠ” ì‚­ì œí•˜ì§€ ì•Šê³  ë³´ì¡´)
              targetIds.forEach(tId => {
                // ê·¸ë¦¬ë“œ í™•ì¸
                for (let gy = 0; gy < ROWS; gy++) {
                  for (let gx = 0; gx < COLS; gx++) {
                    if (grid[gy][gx] && grid[gy][gx].id === tId) grid[gy][gx].isVibrating = true;
                  }
                }
                // ë‚™í•˜ ë¸Œë¦­ í™•ì¸
                fallingBricks.forEach(fb => {
                  if (fb.id === tId) fb.isVibrating = true;
                });
              });

              // [2] 0.2ì´ˆ ì§„ë™ í›„ì— ë°ì´í„° ì‚­ì œ ë° ì¤‘ë ¥ ì ìš©
              setTimeout(() => {
                // 1. ë‚™í•˜ ì¤‘ì¸ ë¸Œë¦­ ë¦¬ìŠ¤íŠ¸ì—ì„œ ë¨¼ì € ì œê±°
                fallingBricks = fallingBricks.filter(b => !targetIds.includes(b.id));

                // 2. ê·¸ë¦¬ë“œì— ìˆëŠ” ë¸Œë¦­ë“¤ ì²˜ë¦¬
                targetIds.forEach((tId) => {
                  loop: for (let gy = 0; gy < ROWS; gy++) {
                    for (let gx = 0; gx < COLS; gx++) {
                      if (grid[gy][gx] && grid[gy][gx].id === tId) {
                        // ì§„ë™ ë„ê³  íŒŒí¸ íš¨ê³¼ ë° ì†Œë©¸ ìƒíƒœ ëŒì…
                        grid[gy][gx].isVibrating = false;
                        grid[gy][gx].isDestroying = true;
                        createBurstEffect(gx, gy);

                        // [í•µì‹¬ ìˆ˜ì •] 250ms ë’¤ì— ì§€ìš¸ ë•Œ, ì¢Œí‘œë¥¼ ë¯¿ì§€ ë§ê³  IDë¡œ ë‹¤ì‹œ ì°¾ìŠµë‹ˆë‹¤.
                        const targetIdForDelete = tId;

                        setTimeout(() => {
                          // ê·¸ë¦¬ë“œ ì „ì²´ë¥¼ ìŠ¤ìº”í•´ì„œ í•´ë‹¹ IDë¥¼ ê°€ì§„ ì ¤ë¦¬ë¥¼ ì°¾ì•„ '0'ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
                          // ì´ë ‡ê²Œ í•˜ë©´ ì¤‘ë ¥ ë•Œë¬¸ì— ìœ„ì¹˜ê°€ ë°”ë€Œì—ˆì–´ë„ ì •í™•íˆ ì°¾ì•„ ì§€ì›ë‹ˆë‹¤.
                          for (let dy = 0; dy < ROWS; dy++) {
                            for (let dx = 0; dx < COLS; dx++) {
                              if (grid[dy][dx] && grid[dy][dx].id === targetIdForDelete) {
                                grid[dy][dx] = 0;
                                applyGravity(); // ì§€ìš´ í›„ ì¤‘ë ¥ ì ìš©
                                return; // ì§€ì› ìœ¼ë©´ í•´ë‹¹ ID íƒìƒ‰ ì¢…ë£Œ
                              }
                            }
                          }
                        }, 250);

                        break loop;
                      }
                    }
                  }
                });
              }, 200);

              score += 100 * combo;
              scoreEl.innerText = score.toLocaleString();
              comboEl.innerText = `${combo} COMBO!`;
              comboEl.style.display = 'inline';
              try {
                matchSfx.currentTime = 0;
                matchSfx.play().catch(e => { });
              } catch (e) { }

              if (score - lastItemScore >= ITEM_THRESHOLD) {
                spawnItem();
                lastItemScore = score;
              }
            } else {
              try {
                matchFailedSfx.currentTime = 0;
                matchFailedSfx.play().catch(e => { });
              } catch (e) { }
              selectedBricks = [];
            }
          }
        }
      }
    }

    function executeCrossBomb(cx, cy) {
      for (let i = 0; i < COLS; i++) { if (grid[cy][i]) { grid[cy][i].isDestroying = true; createBurstEffect(i, cy, "#a349eb"); } }
      for (let j = 0; j < ROWS; j++) { if (grid[j][cx]) { grid[j][cx].isDestroying = true; createBurstEffect(cx, j, "#a349eb"); } }
      setTimeout(() => {
        for (let i = 0; i < COLS; i++) grid[cy][i] = 0;
        for (let j = 0; j < ROWS; j++) grid[j][cx] = 0;
        applyGravity();
      }, 300);
      try { crossBombSfx.currentTime = 0; crossBombSfx.play().catch(e => { }); } catch (e) { }
    }

    function updateItemUI() {
      document.getElementById('bombCount').innerText = inventory.crossBomb;
      const btn = document.getElementById('bombBtn');
      btn.style.background = isItemMode ? "rgba(163, 73, 235, 0.8)" : "rgba(163, 73, 235, 0.2)";
      btn.style.boxShadow = isItemMode ? "0 0 15px #a349eb" : "none";
    }

    function applyGravity() {
      let moved = false;
      for (let x = 0; x < COLS; x++) {
        for (let y = ROWS - 1; y > 0; y--) {
          if (grid[y][x] === 0) {
            for (let k = y - 1; k >= 0; k--) {
              if (grid[k][x] !== 0 && !grid[k][x].isDestroying) {
                grid[y][x] = grid[k][x]; grid[k][x] = 0; moved = true; break;
              }
            }
          }
        }
      }
      if (moved) setTimeout(globalAutoCheck, 100);
    }

    function globalAutoCheck() {
      for (let y = ROWS - 1; y >= 0; y--) for (let x = 0; x < COLS; x++) if (grid[y][x]) checkAutoMatch(x, y);
    }

    function checkAutoMatch(x, y) {
      if (!grid[y] || !grid[y][x] || grid[y][x].isDestroying) return;
      const nx = x + 1;
      if (nx < COLS && grid[y][nx] && !grid[y][nx].isDestroying) {
        if (grid[y][x].value + grid[y][nx].value === 10) {
          const b1 = grid[y][x], b2 = grid[y][nx];

          // [ê°œì„ ] ì˜¤í† ë§¤ì¹­ë„ ì¦‰ì‹œ ì§„ë™ ì‹œì‘!
          b1.isVibrating = true; b2.isVibrating = true;

          autoCombo = Math.min(autoCombo + 1, 5);
          score += 50 * autoCombo;
          scoreEl.innerText = score.toLocaleString();
          try { matchSfx.currentTime = 0; matchSfx.play().catch(e => { }); } catch (e) { }

          // 0.2ì´ˆ ì§„ë™ í›„ íˆ¬ëª…í™” ë° ì‚­ì œ ì§„í–‰
          // 0.2ì´ˆ ì§„ë™ í›„ íˆ¬ëª…í™” ë° ì‚­ì œ ì§„í–‰
          setTimeout(() => {
            b1.isVibrating = false; b2.isVibrating = false;
            b1.isDestroying = true; b2.isDestroying = true;
            createBurstEffect(x, y, "#00ffcc");
            createBurstEffect(nx, y, "#00ffcc");

            // [í•µì‹¬ ìˆ˜ì •] ì¢Œí‘œ(y, x)ê°€ ì•„ë‹ˆë¼ ê°ì²´ ìì²´ë¥¼ ì¶”ì í•´ì„œ ì‚­ì œ
            setTimeout(() => {
              let deleted = false;
              for (let gy = 0; gy < ROWS; gy++) {
                for (let gx = 0; gx < COLS; gx++) {
                  // ê·¸ë¦¬ë“œë¥¼ ëŒë©° b1 ë˜ëŠ” b2 ê°ì²´ì™€ ì¼ì¹˜í•˜ëŠ” ì¹¸ì„ ì°¾ì•„ 0ìœ¼ë¡œ ë§Œë“¦
                  if (grid[gy][gx] === b1 || grid[gy][gx] === b2) {
                    grid[gy][gx] = 0;
                    deleted = true;
                  }
                }
              }
              // í•˜ë‚˜ë¼ë„ ì§€ì›Œì¡Œë‹¤ë©´ ì¤‘ë ¥ ì ìš©
              if (deleted) applyGravity();
            }, 250);
          }, 200); // ì°°ì§„ ì§„ë™ ì‹œê°„
        }
      }
    }

    function createBurstEffect(x, y, color = "#ffffff") {
      for (let i = 0; i < 10; i++) effects.push({ px: (x + 0.5) * BLOCK_SIZE, py: (y + 0.5) * BLOCK_SIZE, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, life: 20, color: color });
    }

    function update(currentTime) {
      if (!gameActive || isPaused) return;
      try {
        const dt = currentTime - (lastTime || currentTime);
        lastTime = currentTime;
        let config = STAGES.find(s => score < s.score) || STAGES[STAGES.length - 1];
        spawnCounter += dt;
        if (spawnCounter > config.interval) { spawnBricks(config.count); spawnCounter = 0; }
        for (let i = fallingBricks.length - 1; i >= 0; i--) {
          const b = fallingBricks[i];
          if (!b) continue;
          b.vy = Math.min(TERMINAL_VELOCITY, b.vy + config.gravity * dt);
          b.y += b.vy * dt;
          const gy = Math.floor(b.y + 1);
          if (gy >= ROWS || (gy >= 0 && grid[gy] && grid[gy][b.x] !== 0)) {
            let fy = gy - 1;
            while (fy >= 0 && grid[fy] && grid[fy][b.x] !== 0) fy--;
            if (fy < DEADLINE) { gameOver(); return; }
            if (fy >= 0 && grid[fy]) {
              grid[fy][b.x] = { value: b.value, id: b.id, isDestroying: false };
              fallingBricks.splice(i, 1);
              setTimeout(() => { globalAutoCheck(); applyGravity(); }, 30);
            }
          }
        }
        fieldItems.forEach((it, i) => { it.x += it.vx; it.angle += 0.05; if (it.x > canvas.width + 50) fieldItems.splice(i, 1); });
        draw();
        requestAnimationFrame(update);
      } catch (error) { requestAnimationFrame(update); }
    }

    function draw() {
      // 1. í™”ë©´ ì´ˆê¸°í™”
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 2. ë°°ê²½ ê²©ì (ë‹¨ìˆœí™”)
      ctx.strokeStyle = "#25374a";
      ctx.lineWidth = 1;
      for (let i = 0; i <= COLS; i++) {
        ctx.beginPath(); ctx.moveTo(i * BLOCK_SIZE, 0); ctx.lineTo(i * BLOCK_SIZE, canvas.height); ctx.stroke();
      }
      for (let j = 0; j <= ROWS; j++) {
        ctx.beginPath(); ctx.moveTo(0, j * BLOCK_SIZE); ctx.lineTo(canvas.width, j * BLOCK_SIZE); ctx.stroke();
      }
      // [ë³µêµ¬] 3. ë°ë“œë¼ì¸(ìœ„í—˜ ë¼ì¸) ê·¸ë¦¬ê¸°
      const isDanger = checkDanger();
      // ìœ„í—˜ ìƒíƒœì¼ ë•Œ 0.25ì´ˆ ê°„ê²©ìœ¼ë¡œ ê¹œë¹¡ì´ëŠ” íš¨ê³¼
      ctx.strokeStyle = (isDanger && Math.floor(Date.now() / 250) % 2 === 0) ? "transparent" : (isDanger ? "#ff0000" : "#ff4b2b");
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, DEADLINE * BLOCK_SIZE);
      ctx.lineTo(canvas.width, DEADLINE * BLOCK_SIZE);
      ctx.stroke();

      // 3. ì•ˆì°©ëœ ë¸Œë¦­ ê·¸ë¦¬ê¸° (ê°€ì¥ ì¤‘ìš”)
      // forEach ëŒ€ì‹  ì—ëŸ¬ì— ê°•í•œ ì´ì¤‘ forë¬¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = grid[y][x];
          if (cell && cell !== 0) {
            ctx.save();
            // íˆ¬ëª…ë„ ì„¤ì •
            if (cell.isDestroying) {
              ctx.globalAlpha = 0.3;
            } else {
              ctx.globalAlpha = 1.0;
            }

            // drawBrick í˜¸ì¶œ ì‹œ ì—ëŸ¬ê°€ ë‚˜ë„ ë£¨í”„ê°€ ê¹¨ì§€ì§€ ì•Šê²Œ ì²˜ë¦¬
            try {
              drawBrick(x, y, cell.value, cell.isVibrating === true);
            } catch (e) {
              console.error("Drawing error at", x, y);
            }
            ctx.restore();
          }
        }
      }

      // 4. ë‚™í•˜ ë¸Œë¦­ ê·¸ë¦¬ê¸°
      fallingBricks.forEach(b => {
        if (b) {
          ctx.save();
          drawBrick(b.x, b.y, b.value, b.isVibrating === true);
          ctx.restore();
        }
      });

      // 5. ì„ íƒ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸° (ì´ ë¶€ë¶„ì´ ë²”ì¸ì´ì—ˆìœ¼ë¯€ë¡œ ë¡œì§ì„ ë¶„ë¦¬)
      // s.idë¥¼ ì´ìš©í•´ gridë¥¼ ë’¤ì§€ì§€ ì•Šê³ , s.x, s.y ì¢Œí‘œë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ê±°ë‚˜
      // grid ì¡°íšŒë¥¼ ìµœì†Œí™”í•©ë‹ˆë‹¤.
      selectedBricks.forEach(s => {
        ctx.save();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 4;
        // ë§¤ì¹­ ì„±ê³µí•´ì„œ ì§„ë™ ì¤‘ì¼ ë•Œë„ í…Œë‘ë¦¬ê°€ ìœ ì§€ë˜ë„ë¡ í•©ë‹ˆë‹¤.
        ctx.strokeRect(s.x * BLOCK_SIZE + 5, s.y * BLOCK_SIZE + 5, BLOCK_SIZE - 10, BLOCK_SIZE - 10);
        ctx.restore();
      });

      // 6. íŒŒí¸ íš¨ê³¼ (ìœ ì§€)
      effects = effects.filter(ef => ef.life > 0);
      effects.forEach((ef) => {
        ctx.save();
        ctx.fillStyle = ef.color;
        ctx.globalAlpha = ef.life / 20;
        ctx.beginPath(); ctx.arc(ef.px, ef.py, 3, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
        ef.px += ef.vx; ef.py += ef.vy; ef.life--;
      });
    }

    function drawBrick(x, y, val, vibrate = false) {
      // 1. ì¢Œí‘œ ê³„ì‚° (vibrate ì‹œ ìˆ˜ì •ì„ ìœ„í•´ letìœ¼ë¡œ ì„ ì–¸)
      let px = x * BLOCK_SIZE;
      let py = y * BLOCK_SIZE;

      // ì§„ë™ ì¤‘ì´ë¼ë©´ ì¢Œí‘œë¥¼ ë¬´ì‘ìœ„ë¡œ í”ë“¦ (ìƒìˆ˜ ì—ëŸ¬ í•´ê²° ì§€ì )
      if (vibrate === true) {
        px += (Math.random() - 0.5) * 6;
        py += (Math.random() - 0.5) * 6;
      }

      // 2. ë¯¸ë¦¬ ë¡œë“œí•´ë‘” ì´ë¯¸ì§€ ê°ì²´ ê°€ì ¸ì˜¤ê¸°
      const img = brickImages[val];

      // 3. ë Œë”ë§ ë¡œì§
      if (img && img.complete && img.naturalWidth !== 0) {
        // [A] ì´ë¯¸ì§€ê°€ ì •ìƒ ë¡œë“œëœ ê²½ìš°: ì ¤ë¦¬ ì´ë¯¸ì§€ë§Œ ì¶œë ¥ (ìˆ«ì í‘œì‹œ ì•ˆ í•¨)
        ctx.drawImage(img, px + 2, py + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
      } else {
        // [B] ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ (ë³´í—˜ìš© ë°±ì—…): ìƒ‰ìƒ ë°•ìŠ¤ì™€ ìˆ«ì ì¶œë ¥
        const colors = {
          1: "#FFFFFF", 2: "#FF0000", 3: "#FF7F00", 4: "#FFFF00", 5: "#00FF00",
          6: "#0000FF", 7: "#4B0082", 8: "#8B00FF", 9: "#000000"
        };
        ctx.fillStyle = colors[val] || "#CCC";

        // ê²½ë¡œ ì´ˆê¸°í™” ë° ë°•ìŠ¤ ê·¸ë¦¬ê¸°
        ctx.beginPath();
        if (ctx.roundRect) {
          ctx.roundRect(px + 4, py + 4, BLOCK_SIZE - 8, BLOCK_SIZE - 8, 8);
          ctx.fill();
        } else {
          ctx.fillRect(px + 4, py + 4, BLOCK_SIZE - 8, BLOCK_SIZE - 8);
        }

        // ë°±ì—…ìš© ìˆ«ì í…ìŠ¤íŠ¸ í‘œì‹œ
        ctx.fillStyle = [1, 3, 4, 5].includes(val) ? "#000" : "#FFF";
        ctx.font = `bold ${BLOCK_SIZE * 0.4}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(val, px + BLOCK_SIZE / 2, py + BLOCK_SIZE / 2);
      }
    }

    function startGame() {
      canvas.style.filter = "none"; canvas.style.transform = "scale(1)";
      gameActive = true; isPaused = false; score = 0; combo = 0; autoCombo = 0; lastMatchTime = 0; lastItemScore = 0; inventory.crossBomb = 0;
      grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      fallingBricks = []; selectedBricks = []; effects = []; fieldItems = [];
      scoreEl.innerText = "0"; comboEl.style.display = 'none'; updateItemUI();
      try { endSfx.pause(); endSfx.currentTime = 0; gameOverSfx.pause(); gameOverSfx.currentTime = 0; bgm.currentTime = 0; bgm.play().catch(e => { }); } catch (e) { }
      document.getElementById('start-screen').classList.add('hidden');
      document.getElementById('gameover-screen').classList.add('hidden');
      lastTime = performance.now(); requestAnimationFrame(update);
    }


    function gameOver() {
      // 0. ê²Œì„ ìƒíƒœ ë° BGM ì •ì§€
      gameActive = false;
      if (bgm) bgm.pause();

      // 1. [ê¸°ë¡ í™•ì¸] ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ í•˜ì´ìŠ¤ì½”ì–´ ê°€ì ¸ì˜¤ê¸° ë° ë¹„êµ
      let savedBest = localStorage.getItem('tenten_best') || 0;
      savedBest = parseInt(savedBest);
      let isNewRecord = false;

      if (score > savedBest) {
        savedBest = score;
        localStorage.setItem('tenten_best', savedBest); // ì‹ ê¸°ë¡ ë¡œì»¬ ì €ì¥
        isNewRecord = true;
        // [ì¶”ê°€] ì‹ ê¸°ë¡ ë‹¬ì„± ì‹œì—ë§Œ êµ¬ê¸€ ì‹œíŠ¸ë¡œ ì „ì†¡!
        // [ìˆ˜ì •] ì ìˆ˜ë¥¼ ë¨¼ì € ë³´ë‚´ê³ , ê·¸ 'ì„±ê³µ ì‘ë‹µ'ì„ ë°›ì€ í›„ì— ë­í‚¹ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.
        sendRankToServer(playerName, savedBest).then(() => {
          loadRanking();
        });
      } else {
        loadRanking();
      }

      // 2. [ì—°ì¶œ] í™”ë©´ í•„í„° ë° ë³€í˜• ì—°ì¶œ (ì„¸í”¼ì•„ + ë¸”ëŸ¬ + ì¶•ì†Œ)
      canvas.style.transition = "filter 0.5s ease, transform 0.5s ease";
      canvas.style.filter = "sepia(100%) saturate(300%) hue-rotate(-50deg) blur(5px)";
      canvas.style.transform = "scale(0.98)";

      // 3. [ìŒí–¥] ì—”ë”© íš¨ê³¼ìŒ(ì§§ì€ ì •ì§€ íš¨ê³¼ìŒ) ì¬ìƒ
      try {
        endSfx.currentTime = 0;
        endSfx.play().catch(e => { });
      } catch (e) { }

      // 4. [ì§€ì—° ì‹¤í–‰] 2ì´ˆ ëŒ€ê¸° í›„ ê²Œì„ì˜¤ë²„ ê²°ê³¼ í™”ë©´ í‘œì‹œ
      setTimeout(() => {
        // í˜„ì¬ ì ìˆ˜ ì£¼ì… ë° ì½¤ë§ˆ í‘œì‹œ
        const finalScoreDisplayEl = document.getElementById('finalScoreDisplay');
        if (finalScoreDisplayEl) {
          finalScoreDisplayEl.innerText = score.toLocaleString();

          // ì‹ ê¸°ë¡ì¼ ê²½ìš° ì ìˆ˜ ìƒ‰ìƒì„ ë¯¼íŠ¸ìƒ‰(#00ffcc)ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ê°•ì¡°
          if (isNewRecord) {
            finalScoreDisplayEl.style.color = "#00ffcc";
          } else {
            finalScoreDisplayEl.style.color = "#ffce00"; // ê¸°ì¡´ ë…¸ë€ìƒ‰ ìœ ì§€
          }
        }

        // í•˜ì´ìŠ¤ì½”ì–´(BEST) ê°’ ì£¼ì…
        const bestScoreDisplayEl = document.getElementById('bestScoreDisplay');
        if (bestScoreDisplayEl) {
          // ì‹ ê¸°ë¡ì¼ ê²½ìš° "NEW RECORD!" í…ìŠ¤íŠ¸ë¥¼ ë§ë¶™ì—¬ ì¾Œê° ì¦í­
          bestScoreDisplayEl.innerText = isNewRecord ?
            savedBest.toLocaleString() + " (NEW!)" :
            savedBest.toLocaleString();
        }

        // ê²Œì„ì˜¤ë²„ ë ˆì´ì–´ í‘œì‹œ
        const gameOverScreen = document.getElementById('gameover-screen');
        if (gameOverScreen) {
          gameOverScreen.classList.remove('hidden');
        }

        // ê²°ê³¼ì°½ ì „ìš© ë°°ê²½ ìŒì•…(ë£¨í”„) ì¬ìƒ
        try {
          gameOverSfx.currentTime = 0;
          gameOverSfx.play().catch(e => { });
        } catch (e) { }
      }, 2000);
    }

    function showStartScreen() {
      //ìœ ì €ì•„ì´ë”” ë¬»ê³  ì·¨ì†Œì‹œ ìë™ ìƒì„± ì €ì¥;
      setupPlayerName();
      const playerEl = document.getElementById('playerDisplay');
      if (playerEl) playerEl.innerText = "PLAYER: " + playerName;
      // 1. [ì¶”ê°€] ì‹œì‘ í™”ë©´ì´ ëœ° ë•Œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë² ìŠ¤íŠ¸ ìŠ¤ì½”ì–´ ê°€ì ¸ì˜¤ê¸°
      const savedBest = localStorage.getItem('tenten_best') || 0;
      const mainBestEl = document.getElementById('mainBestDisplay'); // ìƒë‹¨ì— ì¶”ê°€í•œ BEST í‘œì‹œìš©
      if (mainBestEl) {
        mainBestEl.innerText = "BEST: " + parseInt(savedBest).toLocaleString();
      }

      // [ì¶”ê°€] ê¸°ì¡´ ìœ ì € ì¤‘ ì‹œíŠ¸ì— ë“±ë¡ëœ ì ì´ ì—†ëŠ” ê²½ìš°(ë˜ëŠ” í•œ ë²ˆ ë” í™•ì¸ì°¨) ì²« ì ‘ì† ì‹œ ì „ì†¡
      // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— 'ë“±ë¡ì—¬ë¶€'ë¥¼ ì²´í¬í•´ì„œ ë”± í•œ ë²ˆë§Œ ë³´ë‚´ê²Œ í•¨
      const isRegistered = localStorage.getItem('tenten_rank_registered');
      if (savedBest > 0 && !isRegistered) {
        sendRankToServer(playerName, savedBest);
        localStorage.setItem('tenten_rank_registered', 'true'); // ë“±ë¡ ì™„ë£Œ ë§ˆí¬
      }

      // 2. [ê¸°ì¡´ ê¸°ëŠ¥] í™”ë©´ ì „í™˜ (ìœ ì§€)
      document.getElementById('gameover-screen').classList.add('hidden');
      document.getElementById('start-screen').classList.remove('hidden');

      // 3. [ê¸°ì¡´ ê¸°ëŠ¥] ìº”ë²„ìŠ¤ í•„í„° ì´ˆê¸°í™” (ìœ ì§€)
      canvas.style.filter = "none";
      canvas.style.transform = "scale(1)";

      // 4. [ê¸°ì¡´ ê¸°ëŠ¥] ì‚¬ìš´ë“œ ì œì–´ (ìœ ì§€)
      try {
        endSfx.pause();
        endSfx.currentTime = 0;
        gameOverSfx.play().catch(e => { }); // ëŒ€ê¸° í™”ë©´ ìŒì•… ì¬ìƒ
      } catch (e) { }
    }

    function togglePause() { isPaused = !isPaused; if (!isPaused) { lastTime = performance.now(); requestAnimationFrame(update); } }
    function checkDanger() { return grid[DEADLINE + 1] && grid[DEADLINE + 1].some(c => c !== 0); }

    // ë­í‚¹ ì„œë²„(êµ¬ê¸€ ì‹œíŠ¸)ë¡œ ì ìˆ˜ ë³´ë‚´ê¸°
    function sendRankToServer(name, score) {
      if (!SCRIPT_URL || SCRIPT_URL.includes("ì—¬ê¸°ì—")) return Promise.resolve();

      return fetch(SCRIPT_URL, {
        method: "POST",
        mode: "no-cors", // CORS ì—ëŸ¬ ë°©ì§€ (no-corsëŠ” ì‘ë‹µ í™•ì¸ì´ ì–´ë µì§€ë§Œ ë°ì´í„°ëŠ” ì „ì†¡ë¨)
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: name, score: score })
      }).then(() => {
        console.log("ë­í‚¹ ë“±ë¡ ì™„ë£Œ:", name, score);
      }).catch(e => console.error("ë­í‚¹ ë“±ë¡ ì‹¤íŒ¨:", e));
    }

    function loadRanking() {
      const rankingListEl = document.getElementById('ranking-list');

      // 1. êµ¬ê¸€ ì‹œíŠ¸ì— GET ìš”ì²­ (doGet í•¨ìˆ˜ ì‹¤í–‰)
      fetch(SCRIPT_URL)
        .then(response => response.json())
        .then(data => {
          rankingListEl.innerHTML = ""; // ê¸°ì¡´ ë¡œë”© ë©”ì‹œì§€ ì‚­ì œ

          // ìƒìœ„ 5ëª…ë§Œ í‘œì‹œ
          data.slice(0, 5).forEach((entry, index) => {
            const row = document.createElement('div');
            row.style.display = "flex";
            row.style.justifyContent = "space-between";
            row.style.borderBottom = "1px solid rgba(255,255,255,0.1)";
            row.style.padding = "3px 0";

            // ë‚´ ì´ë¦„ê³¼ ê°™ìœ¼ë©´ ê°•ì¡°ìƒ‰ ì ìš©
            const isMe = entry[0] === playerName ? "color: #00ffcc; font-weight: bold;" : "color: #fff;";

            row.innerHTML = `
                <span style="${isMe}">${index + 1}. ${entry[0]}</span>
                <span style="${isMe}">${parseInt(entry[1]).toLocaleString()}</span>
            `;
            rankingListEl.appendChild(row);
          });
        })
        .catch(e => {
          console.error("ë­í‚¹ ë¡œë“œ ì‹¤íŒ¨:", e);
          rankingListEl.innerHTML = "<p style='text-align:center;'>ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>";
        });
    }

    init();
  </script>
</body>

</html>
