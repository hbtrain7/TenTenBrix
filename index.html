<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>TenTenBrix v3.6 - Balance Algorithm Restored</title>
  <style>
    :root {
      --primary-color: #e94560;
      --text-color: #ffffff;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #1a1a2e;
      font-family: 'Segoe UI', sans-serif;
      color: var(--text-color);
      touch-action: none;
    }

    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
      background-color: #16213e;
      border: 3px solid #30475e;
      cursor: pointer;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 5;
      padding: 20px;
      box-sizing: border-box;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      font-size: 1.4rem;
      font-weight: bold;
    }

    .hud-item {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 25px;
      border-radius: 12px;
      pointer-events: auto;
      border: 2px solid var(--primary-color);
    }

    .screen {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      pointer-events: auto;
    }

    .screen.hidden {
      display: none;
    }

    h1 {
      font-size: 3.5rem;
      color: var(--primary-color);
      text-shadow: 0 0 15px var(--primary-color);
      margin: 0 0 10px 0;
    }

    .btn {
      background: var(--primary-color);
      border: none;
      padding: 18px 50px;
      font-size: 1.8rem;
      color: white;
      border-radius: 60px;
      cursor: pointer;
      transition: 0.2s;
      font-weight: bold;
      box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
    }
  </style>
</head>

<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
      <div class="hud">
        <div class="hud-item">SCORE: <span id="scoreVal">0</span> <span id="combo-text"
            style="color:#00ffcc; margin-left:10px; display:none;"></span></div>
        <div id="pauseBtn" class="hud-item" style="cursor:pointer;" onclick="togglePause()">PAUSE</div>
      </div>
    </div>
    <div id="start-screen" class="screen">
      <h1>TenTenBrix</h1>
      <p style="font-size: 1.2rem; margin-bottom: 30px; color: #aaa;">AI 보정 알고리즘 탑재 완료!</p>
      <button id="realStartBtn" class="btn">START GAME</button>
    </div>
    <div id="gameover-screen" class="screen hidden">
      <h1>GAME OVER</h1>
      <p id="finalScoreDisplay" style="font-size: 2.5rem; margin-bottom: 20px; color: #ffce00;">SCORE: 0</p>
      <button class="btn" onclick="showStartScreen()">RETRY</button>
    </div>
  </div>

  <script>
    // --- [1] 기본 변수 설정 ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreVal');
    const comboEl = document.getElementById('combo-text');
    const finalScoreEl = document.getElementById('finalScoreDisplay');

    const COLS = 7, ROWS = 11;
    let BLOCK_SIZE, grid = [], score = 0, combo = 0, autoCombo = 0, lastMatchTime = 0;
    let gameActive = false, isPaused = false, fallingBricks = [], lastTime = 0, spawnCounter = 0, selectedBricks = [];
    let effects = [];

    const TERMINAL_VELOCITY = 0.025;
    const STAGES = [
      { score: 800, interval: 1000, gravity: 0.00003, count: 1 },
      { score: 5000, interval: 1000, gravity: 0.00004, count: 2 },
      { score: 20000, interval: 900, gravity: 0.00005, count: 2 },
      { score: 50000, interval: 900, gravity: 0.00006, count: 3 }
    ];

    const introSfx = new Audio('sfx/intro.wav');
    const bgm = new Audio('sfx/bgm.wav');
    const matchSfx = new Audio('sfx/match.wav');
    const endSfx = new Audio('sfx/endSfx .wav');
    const gameOverSfx = new Audio('sfx/gameover.wav');
    introSfx.loop = true; introSfx.volume = 0.5; bgm.loop = true; bgm.volume = 0.5; gameOverSfx.loop = true;

    // --- [2] 초기화 시스템 ---    
    function init() {
      resize();
      const playIntroOnce = () => {
        introSfx.play().catch(e => console.log("재생 권한 대기 중..."));
        // 한 번 재생되면 이 이벤트 리스너들은 삭제 (중복 실행 방지)
        window.removeEventListener('mousedown', playIntroOnce);
        window.removeEventListener('touchstart', playIntroOnce);
      };
      // 화면 어디든 누르면 인트로 재생 시작!
      window.addEventListener('mousedown', playIntroOnce);
      window.addEventListener('touchstart', playIntroOnce);

      grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      window.addEventListener('resize', resize);
      canvas.addEventListener('mousedown', (e) => handleInput(e));
      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e.touches[0]); });
      document.getElementById('realStartBtn').onclick = startGame;
    }

    function resize() {
      BLOCK_SIZE = Math.min(window.innerWidth / (COLS + 0.5), (window.innerHeight - 120) / ROWS);
      canvas.width = COLS * BLOCK_SIZE; canvas.height = ROWS * BLOCK_SIZE;
    }

    // --- [3] 보정 알고리즘 (Balance System) ---
    // 현재 화면에 있는 숫자들의 빈도수를 체크하는 함수
    function getDigitCounts() {
      const counts = Array(10).fill(0);
      grid.forEach(row => row.forEach(cell => { if (cell !== 0) counts[cell.value]++; }));
      fallingBricks.forEach(b => { counts[b.value]++; });
      return counts;
    }

    // 보정된 랜덤 숫자 생성 (생성 로직 복구)
    function getBalancedValue() {
      const counts = getDigitCounts();
      // 화면에 가장 많은 숫자 찾기
      const mostFreqValue = counts.indexOf(Math.max(...counts.slice(1)));

      // 특정 숫자가 3개 이상 쌓였는데 짝꿍(합이 10)이 없으면 30% 확률로 짝꿍 생성
      if (counts[mostFreqValue] >= 3 && Math.random() < 0.3) {
        return 10 - mostFreqValue;
      }
      // 기본은 1~9 완전 랜덤
      return Math.floor(Math.random() * 9) + 1;
    }

    function spawnBricks(count) {
      for (let i = 0; i < count; i++) {
        const x = Math.floor(Math.random() * COLS);
        if (grid[0][x] !== 0) { gameOver(); return; }

        // [복구 완료] 보정 알고리즘 적용
        const val = getBalancedValue();

        fallingBricks.push({ id: Date.now() + Math.random(), x: x, y: -1, value: val, vy: 0 });
      }
    }

    // --- [4] 애니메이션 및 게임 루프 ---
    function createBurstEffect(x, y, color = "#ffffff") {
      for (let i = 0; i < 12; i++) {
        effects.push({
          px: (x + 0.5) * BLOCK_SIZE, py: (y + 0.5) * BLOCK_SIZE,
          vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
          life: 30, color: color
        });
      }
    }

    function update(currentTime) {
      if (!gameActive || isPaused) return;
      if (!lastTime || (currentTime - lastTime > 100)) { lastTime = currentTime; requestAnimationFrame(update); return; }
      const dt = Math.min(currentTime - lastTime, 50);
      lastTime = currentTime;

      let config = STAGES[0];
      for (let s of STAGES) { if (score >= s.score) config = s; else break; }

      spawnCounter += dt;
      if (spawnCounter > config.interval) { spawnBricks(config.count); spawnCounter = 0; }

      for (let i = fallingBricks.length - 1; i >= 0; i--) {
        const b = fallingBricks[i];
        b.vy = Math.min(TERMINAL_VELOCITY, b.vy + config.gravity * dt);
        b.y += b.vy * dt;
        const gy = Math.floor(b.y + 1);

        if (gy >= ROWS || (gy >= 0 && grid[gy][b.x] !== 0)) {
          let fy = gy - 1;
          while (fy >= 0 && grid[fy][b.x] !== 0) { fy--; }
          if (fy < 2) {
            if (fy >= 0) grid[fy][b.x] = { value: Number(b.value), isDestroying: false };
            draw(); gameOver(); return;
          }
          if (fy >= 0) {
            grid[fy][b.x] = { value: Number(b.value), isDestroying: false };
            checkAutoMatch(b.x, fy);
          }
          fallingBricks.splice(i, 1);
        }
      }
      draw();
      requestAnimationFrame(update);
    }

    // --- [5] 매칭 및 중력 시스템 ---
    function checkAutoMatch(x, y) {
      if (!grid[y][x] || grid[y][x].isDestroying) return;
      const val = grid[y][x].value;
      const neighbors = [{ dx: -1 }, { dx: 1 }];
      let matched = false;
      for (let n of neighbors) {
        const nx = x + n.dx;
        if (nx >= 0 && nx < COLS && grid[y][nx] && !grid[y][nx].isDestroying) {
          if (val + grid[y][nx].value === 10) {
            grid[y][x].isDestroying = true; grid[y][nx].isDestroying = true;
            createBurstEffect(x, y, "#00ffcc"); createBurstEffect(nx, y, "#00ffcc");
            autoCombo++; score += 150 * autoCombo; scoreEl.innerText = score.toLocaleString();
            comboEl.innerText = `AUTO x${autoCombo}`; comboEl.style.display = 'inline';
            setTimeout(() => { comboEl.style.display = 'none'; }, 1000);
            try { matchSfx.cloneNode().play(); } catch (e) { }
            setTimeout(() => { grid[y][x] = 0; grid[y][nx] = 0; applyGravity(); }, 300);
            matched = true; break;
          }
        }
      }
      if (!matched) autoCombo = 0;
    }

    function handleInput(e) {
      if (!gameActive || isPaused) return;
      const rect = canvas.getBoundingClientRect();
      const cx = Math.floor((e.clientX - rect.left) / BLOCK_SIZE);
      const cy = Math.floor((e.clientY - rect.top) / BLOCK_SIZE);
      if (cx < 0 || cx >= COLS || cy < 0 || cy >= ROWS) return;
      if (grid[cy][cx] && grid[cy][cx].isDestroying) return;

      let clicked = null;
      const fIdx = fallingBricks.findIndex(b => b.x === cx && Math.round(b.y) === cy);
      if (fIdx > -1) clicked = { ...fallingBricks[fIdx], isFalling: true };
      else if (grid[cy][cx]) clicked = { x: cx, y: cy, value: grid[cy][cx].value, isFalling: false, id: `f-${cx}-${cy}` };

      if (clicked) {
        const idx = selectedBricks.findIndex(s => s.id === clicked.id);
        if (idx > -1) selectedBricks.splice(idx, 1);
        else selectedBricks.push(clicked);

        if (selectedBricks.length === 2) {
          const s1 = selectedBricks[0], s2 = selectedBricks[1];
          if (s1.value + s2.value === 10) {
            const now = Date.now(); combo = (now - lastMatchTime < 3000) ? combo + 1 : 1;
            lastMatchTime = now;
            selectedBricks.forEach(s => {
              if (s.isFalling) { fallingBricks = fallingBricks.filter(b => b.id !== s.id); createBurstEffect(s.x, s.y); }
              else if (grid[s.y][s.x]) {
                grid[s.y][s.x].isDestroying = true; createBurstEffect(s.x, s.y);
                setTimeout(() => { grid[s.y][s.x] = 0; applyGravity(); }, 300);
              }
            });
            score += 100 * combo; scoreEl.innerText = score.toLocaleString();
            comboEl.innerText = `${combo} COMBO!`; comboEl.style.display = 'inline';
            try { matchSfx.cloneNode().play(); } catch (e) { }
          }
          selectedBricks = [];
        }
      }
    }

    function applyGravity() {
      let moved = false;
      for (let x = 0; x < COLS; x++) {
        for (let y = ROWS - 1; y > 0; y--) {
          if (grid[y][x] === 0) {
            for (let k = y - 1; k >= 0; k--) {
              if (grid[k][x] !== 0 && !grid[k][x].isDestroying) {
                grid[y][x] = grid[k][x]; grid[k][x] = 0; moved = true; break;
              }
            }
          }
        }
      }
      if (moved) globalAutoCheck();
    }

    function globalAutoCheck() {
      for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          if (grid[y][x] !== 0 && !grid[y][x].isDestroying) checkAutoMatch(x, y);
        }
      }
    }

    // --- [6] 그리기 시스템 ---
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#25374a"; ctx.lineWidth = 1;
      for (let i = 0; i <= COLS; i++) { ctx.beginPath(); ctx.moveTo(i * BLOCK_SIZE, 0); ctx.lineTo(i * BLOCK_SIZE, canvas.height); ctx.stroke(); }
      for (let j = 0; j <= ROWS; j++) { ctx.beginPath(); ctx.moveTo(0, j * BLOCK_SIZE); ctx.lineTo(canvas.width, j * BLOCK_SIZE); ctx.stroke(); }

      const isDanger = checkDanger();
      ctx.strokeStyle = (isDanger && Math.floor(Date.now() / 250) % 2 === 0) ? "transparent" : (isDanger ? "#ff0000" : "#ff4b2b");
      ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, 2 * BLOCK_SIZE); ctx.lineTo(canvas.width, 2 * BLOCK_SIZE); ctx.stroke();

      grid.forEach((row, y) => row.forEach((cell, x) => {
        if (cell) { ctx.save(); if (cell.isDestroying) ctx.globalAlpha = 0.4; drawBrick(x, y, cell.value); ctx.restore(); }
      }));
      fallingBricks.forEach(b => drawBrick(b.x, b.y, b.value));
      selectedBricks.forEach(s => {
        let dy = s.y; if (s.isFalling) { const b = fallingBricks.find(f => f.id === s.id); if (b) dy = b.y; }
        ctx.strokeStyle = "white"; ctx.lineWidth = 4; ctx.strokeRect(s.x * BLOCK_SIZE + 6, dy * BLOCK_SIZE + 6, BLOCK_SIZE - 12, BLOCK_SIZE - 12);
      });
      effects.forEach((ef, i) => {
        ctx.save(); ctx.fillStyle = ef.color; ctx.globalAlpha = ef.life / 30; ctx.beginPath(); ctx.arc(ef.px, ef.py, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        ef.px += ef.vx; ef.py += ef.vy; ef.life--; if (ef.life <= 0) effects.splice(i, 1);
      });
    }

    function drawBrick(x, y, val) {
      const colors = { 1: "#FFFFFF", 2: "#FF0000", 3: "#FF7F00", 4: "#FFFF00", 5: "#00FF00", 6: "#0000FF", 7: "#4B0082", 8: "#8B00FF", 9: "#000000" };
      const px = x * BLOCK_SIZE, py = y * BLOCK_SIZE;
      ctx.fillStyle = colors[val] || "#CCC"; ctx.fillRect(px + 4, py + 4, BLOCK_SIZE - 8, BLOCK_SIZE - 8);
      ctx.fillStyle = [1, 3, 4, 5].includes(val) ? "#000" : "#FFF"; ctx.font = `bold ${BLOCK_SIZE * 0.5}px Arial`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(val, px + BLOCK_SIZE / 2, py + BLOCK_SIZE / 2);
    }

    function startGame() {
      try {
        if (introSfx) {
          introSfx.pause();
          introSfx.currentTime = 0; // 다음에 다시 인트로를 쓸 때를 대비해 초기화
        }
      } catch (e) {
        console.log("인트로 음악 제어 오류:", e);
      }

      // 2. 게임오버 음악도 혹시 켜져있다면 끄기
      try {
        gameOverSfx.pause();
        gameOverSfx.currentTime = 0;
      } catch (e) { }
      document.getElementById('start-screen').classList.add('hidden');
      document.getElementById('gameover-screen').classList.add('hidden');
      try { bgm.currentTime = 0; bgm.play(); } catch (e) { }
      gameActive = true; score = 0; combo = 0; grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      fallingBricks = []; selectedBricks = []; effects = []; lastTime = performance.now(); scoreEl.innerText = "0"; requestAnimationFrame(update);
    }

    function gameOver() {
      gameActive = false;
      bgm.pause();
      try {
        if (typeof endSfx !== 'undefined') {
          endSfx.currentTime = 0;
          endSfx.play();
        }
      } catch (e) { console.log("종료음 재생 오류:", e); }

      // 3. 효과음 재생 후 여운을 위한 '지연 실행' (setTimeout)
      // endSfx가 짧다고 하셨으니, 1~2초 정도 뒤에 화면을 띄웁니다.
      setTimeout(() => {
        // 게임오버 전용 테마가 있다면 여기서 재생 (사장님의 이전 요구사항)
        try {
          if (typeof gameOverSfx !== 'undefined') {
            gameOverSfx.play();
          }
        } catch (e) { }
        // 4. 최종 점수 기입 및 리트라이 화면 표시
        finalScoreEl.innerText = "SCORE: " + score.toLocaleString();
        document.getElementById('gameover-screen').classList.remove('hidden');
      }, 1500); // 1.5초(1500ms) 대기: 소리 재생 + 1초 정도의 여유 시간
    }

    function showStartScreen() {
      // 1. 모든 음악 정지
      try {
        bgm.pause();
        gameOverSfx.pause();
        gameOverSfx.currentTime = 0;
      } catch (e) { }

      // 2. 인트로 음악 다시 재생
      try {
        if (typeof introSfx !== 'undefined') {
          introSfx.currentTime = 0;
          introSfx.play();
        }
      } catch (e) { }

      // 3. 화면 전환
      document.getElementById('gameover-screen').classList.add('hidden'); // 게임오버 숨기기
      document.getElementById('start-screen').classList.remove('hidden'); // 시작화면 보이기
    }
    function togglePause() { isPaused = !isPaused; document.getElementById('pauseBtn').innerText = isPaused ? "RESUME" : "PAUSE"; if (!isPaused) { lastTime = performance.now(); requestAnimationFrame(update); } }
    function checkDanger() { for (let x = 0; x < COLS; x++) { if (grid[3] && grid[3][x] !== 0) return true; } return false; }

    init();
  </script>
</body>

</html>